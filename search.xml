<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>el-tabs点击时传递item所有内容</title>
      <link href="/Kylin-blog/2024/01/05/el-tabs%E7%82%B9%E5%87%BB%E6%97%B6%E4%BC%A0%E9%80%92item%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9/"/>
      <url>/Kylin-blog/2024/01/05/el-tabs%E7%82%B9%E5%87%BB%E6%97%B6%E4%BC%A0%E9%80%92item%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<ul><li><p>添加：<code>:value=&quot;JSON.stringify(item)&quot;</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-tabs</span> <span class="attr">v-model</span>=<span class="string">&quot;activeName&quot;</span> @<span class="attr">tab-click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-tab-pane</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in menuItems&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:label</span>=<span class="string">&quot;item.moduleName&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">&quot;JSON.stringify(item)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:name</span>=<span class="string">&quot;item.moduleName&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">el-tab-pane</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-tabs</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>el.$attrs.value</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params">el</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(el.<span class="property">$attrs</span>.<span class="property">value</span>));</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> elementUI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>el-menu折叠时的bug</title>
      <link href="/Kylin-blog/2024/01/04/el-menu%E6%8A%98%E5%8F%A0%E6%97%B6%E7%9A%84bug/"/>
      <url>/Kylin-blog/2024/01/04/el-menu%E6%8A%98%E5%8F%A0%E6%97%B6%E7%9A%84bug/</url>
      
        <content type="html"><![CDATA[<ul><li><p>如图所示：在折叠时，菜单标题和右边的箭头没有消失<br><img src="/Kylin-blog/image.png" alt="Alt text"></p></li><li><p>解决方法：</p><ul><li><code>style</code>不加<code>scoped</code><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*由于 element-ui 的&lt;el-menu&gt;标签本身希望里面嵌套的是&lt;el-menu-item&gt;,&lt;el-submenu&gt;,&lt;el-menu-item-group&gt;之一，但是却嵌套了&lt;div&gt;,而导致收折就隐藏不了文字*/</span></span><br><span class="line"><span class="comment">/*隐藏文字*/</span></span><br><span class="line"><span class="selector-class">.el-menu--collapse</span> <span class="selector-class">.el-submenu__title</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*隐藏 &gt; */</span></span><br><span class="line"><span class="selector-class">.el-menu--collapse</span> <span class="selector-class">.el-submenu__title</span> <span class="selector-class">.el-submenu__icon-arrow</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx知识点</title>
      <link href="/Kylin-blog/2023/12/28/nginx%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/Kylin-blog/2023/12/28/nginx%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><ul><li><code>proxy_pass</code>用于<strong>转发请求</strong></li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">8080</span>; <span class="comment">#对外监听端口</span></span><br><span class="line">  <span class="attribute">server_name</span>  localhost; <span class="comment">#主机名称</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#请求路径</span></span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   html; <span class="comment"># Nginx默认值</span></span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 静态化配置，所有静态请求都转发给 nginx 处理，存放目录为 my-project</span></span><br><span class="line">  <span class="section">location</span> <span class="regexp">~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/local/var/www/my-project; <span class="comment"># 静态请求所代理到的根目录</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 动态请求匹配到path为&#x27;node&#x27;的就转发到8002端口处理</span></span><br><span class="line">  <span class="section">location</span> /node/ &#123;  </span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8002; <span class="comment"># 充当服务代理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="root与alias"><a href="#root与alias" class="headerlink" title="root与alias"></a>root与alias</h2><p><strong>root与alias</strong>：这两个指令主要功能都是将url映射为文件路径，以<strong>返回静态文件内容</strong>。主要的差别在于：</p><ul><li><code>root</code>有一个默认值html，可以出现在http、server和location指令块内，并且会将完整的url映射进文件路径中</li><li><code>alias</code>没有默认值，只能出现在location指令块中，并且只会将location后的url映射到文件路径 举例说明：</li></ul><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /root &#123;</span><br><span class="line">  <span class="attribute">root</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /alias &#123;</span><br><span class="line">  <span class="attribute">alias</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当访问<code>localhost/root/</code>时，根据配置的指令值，会在<code>html</code>后加上<code>/root</code>再去访问<code>index.html</code>。所以实际访问的路由地址为<code>localhost/html/root/index.html</code>。这是因为<code>root</code>会将完整的<code>url</code>映射进文件路径中。<br>而访问<code>localhost/alias/</code>时，访问的路由地址为<code>localhost/html/index.html</code></p><h2 id="location匹配规则"><a href="#location匹配规则" class="headerlink" title="location匹配规则"></a><code>location</code>匹配规则</h2><p><code>nginx</code> 的 <code>location</code> 匹配规则是用于指定不同请求 URI 的处理方式的。<code>location</code> 块可以根据不同的匹配规则来定义，以确定应该如何处理特定的请求。以下是 <code>nginx</code> 中常见的 <code>location</code> 匹配规则：</p><ol><li><strong>前缀匹配：</strong></li></ol><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /path/ &#123;</span><br><span class="line">    <span class="comment"># 处理以 &quot;/path/&quot; 开头的 URI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>精确匹配：</strong></li></ol><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> = /exact_path &#123;</span><br><span class="line">    <span class="comment"># 只处理精确匹配 &quot;/exact_path&quot; 的 URI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>正则表达式匹配：</strong></li></ol><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="comment"># 处理以 &quot;.php&quot; 结尾的 URI，使用正则表达式匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>不区分大小写的正则表达式匹配：</strong></li></ol><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* \.png$</span> &#123;</span><br><span class="line">    <span class="comment"># 不区分大小写地处理以 &quot;.png&quot; 结尾的 URI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>最长前缀匹配：</strong></li></ol><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /images/ &#123;</span><br><span class="line">    <span class="comment"># 处理以 &quot;/images/&quot; 开头的 URI，如果匹配成功，停止搜索其他location</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>优先级：</strong><br><code>location</code> 的匹配是按照配置文件中出现的顺序优先匹配的，因此更早出现的 <code>location</code> 具有更高的优先级。</li></ol><p>以上是一些常见的 <code>nginx location</code> 匹配规则。在配置文件中，可以根据实际需求使用这些规则，以确保请求被正确地路由和处理。</p><h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><ul><li><code>rewrite</code>功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标记位实现<strong>URL重写以及重定向</strong>。</li><li>比如：更换域名后需要保持旧的域名能跳转到新的域名上、某网页发生改变需要跳转到新的页面、网站防盗链等等需求。</li><li><code>rewrite</code>只能放在<code>server&#123;&#125;,location&#123;&#125;,if&#123;&#125;</code>中，并且默认只能对域名后边的除去传递的参数外的字符串起作用，<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span>  /static/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^</span>  http://www.abc.com ;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>解释：上面实现的功能：假设网站域名为<code>www.blog.com</code>；那么配置上面的功能是输入<code>www.blog.com/static/</code>时，不管<code>static</code>后面是什么页面（页面也可以不存在），那么最终会同样跳转到<code>www.abc.com</code>这个网站。</p><p><img src="https://img-blog.csdnimg.cn/6b3bb14448f44263bcabd6b79321acdc.png" alt="Alt text"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span>  /audit-report/ &#123;</span><br><span class="line">    <span class="attribute">add_header</span> X-Frame-Options SAMEORIGIN <span class="comment"># 防止页面被嵌套</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span>  /audit-report/ &#123;</span><br><span class="line">    <span class="attribute">proxy_cookie_path</span> / <span class="string">&quot;/; httponly; secure; SameSite=Lax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxy_cookie_path</code>是用于在Nginx中配置代理服务器的指令，它用于设置代理服务器传递的HTTP响应中的Cookie的路径。在你提供的查询中，这个指令被用来设置Cookie的路径为”&#x2F;“，并且附带了一些安全性相关的选项：</p><ol><li><code>httponly</code>：这个选项告诉浏览器只在HTTP请求中发送Cookie，不允许脚本通过<code>document.cookie</code>访问。这有助于减少跨站脚本攻击（XSS）的风险。 </li><li><code>secure</code>：这个选项要求Cookie只能通过加密的连接（HTTPS）传输，提高了数据的安全性，防止在传输过程中被窃听。 </li><li><code>SameSite=Lax</code>：这个选项是为了防止跨站请求伪造（CSRF）攻击。它限制了第三方站点对Cookie的访问，仅在顶级导航时发送Cookie，从而减少了CSRF攻击的潜在风险。</li></ol><p>总体而言，这个配置有助于提高通过Nginx代理服务器传递的Cookie的安全性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scss的基础使用</title>
      <link href="/Kylin-blog/2023/12/26/scss%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/Kylin-blog/2023/12/26/scss%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Sass（Syntactically Awesome Stylesheets）</code>和 <code>SCSS（Sassy CSS）</code>都是用于样式表的预处理器，它们扩展了普通的 <code>CSS</code> 语法，提供了更多的功能和灵活性。以下是它们的主要区别：</p><ol><li><strong>语法格式：</strong> <ul><li><code>Sass</code> 使用严格的缩进来表示代码块，类似于 <code>Python</code>。</li><li><code>SCSS</code> 使用更接近于常规 <code>CSS</code> 的花括号和分号的语法。</li></ul></li><li><strong>文件扩展名：</strong> <ul><li><code>Sass</code> 文件使用 <code>.sass</code> 扩展名。</li><li><code>SCSS</code> 文件使用 <code>.scss</code> 扩展名。</li></ul></li><li><strong>语法风格：</strong> <ul><li><code>Sass</code> 更加简洁，省略了许多常见的符号，如花括号和分号。</li><li><code>SCSS</code> 更接近于常规的 <code>CSS</code> 语法，因此更容易学习和迁移。</li></ul></li><li><strong>兼容性：</strong> <ul><li>由于 <code>SCSS</code> 的语法更接近于 <code>CSS</code>，因此它更容易被现有的 <code>CSS</code> 代码接受，并且可以逐步地将现有的 <code>CSS</code> 文件重命名为 <code>SCSS</code> 并继续工作。</li><li><code>Sass</code> 的语法相对较新，可能需要一些时间来适应。</li></ul></li><li><strong>选择：</strong> <ul><li>选择使用 Sass 还是 SCSS 取决于个人偏好和项目要求。一些开发者喜欢 Sass 的简洁性，而另一些喜欢 SCSS 的类似 CSS 的语法。</li></ul></li></ol><p>在实际使用中，两者都提供了相似的功能，包括变量、嵌套规则、混合（Mixins）等，因此可以根据团队的需求和开发者的偏好进行选择。</p></blockquote><h2 id="1、-（插值语句）"><a href="#1、-（插值语句）" class="headerlink" title="1、#{ }（插值语句）"></a>1、<code>#&#123; &#125;</code>（插值语句）</h2><ul><li>有引号字符串将被编译为无引号字符串，这样便于在 <code>mixin</code> 中引用选择器名：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin firefox-message($selector) &#123;</span><br><span class="line">  body.firefox #&#123;$selector&#125;:before &#123;</span><br><span class="line">    content: &quot;Hi, Firefox users!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@include firefox-message(&quot;.header&quot;);</span><br><span class="line">// 编译为</span><br><span class="line">body.firefox .header:before &#123;</span><br><span class="line">  content: &quot;Hi, Firefox users!&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>#&#123;&#125;</code>插值语句可以在选择器或属性名中使用变量</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$name: foo;</span><br><span class="line">$attr: border;</span><br><span class="line">p.#&#123;$name&#125; &#123;</span><br><span class="line">  #&#123;$attr&#125;-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">// 编译为：</span><br><span class="line">p.foo &#123;</span><br><span class="line">  border-color: blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、混入指令"><a href="#2、混入指令" class="headerlink" title="2、混入指令"></a>2、混入指令</h2><ul><li><code>@mixin</code> 指令允许我们定义一个可以在整个样式表中<strong>重复使用的样式</strong></li><li><code>@include</code> 指令可以将混入<code>（mixin）</code>引入到文档中</li></ul><h3 id="2-1、标准形式"><a href="#2-1、标准形式" class="headerlink" title="2.1、标准形式"></a>2.1、标准形式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义页面一个区块基本的样式</span><br><span class="line">@mixin block &#123;</span><br><span class="line">    width: 96%;</span><br><span class="line">    margin-left: 2%;</span><br><span class="line">    border-radius: 8px;</span><br><span class="line">    border: 1px #f6f6f6 solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用混入</span><br><span class="line">.container &#123;</span><br><span class="line">    .block &#123;</span><br><span class="line">        @include block;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2、嵌入选择器"><a href="#2-2、嵌入选择器" class="headerlink" title="2.2、嵌入选择器"></a>2.2、嵌入选择器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin warning-text &#123;</span><br><span class="line">    .warn-text &#123;</span><br><span class="line">        font-size: 12px;</span><br><span class="line">        color: rgb(255, 253, 123);</span><br><span class="line">        line-height: 180%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用混入</span><br><span class="line">.container &#123;</span><br><span class="line">    @include warning-text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3、使用变量（单参数）"><a href="#2-3、使用变量（单参数）" class="headerlink" title="2.3、使用变量（单参数）"></a>2.3、使用变量（单参数）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义flex布局元素纵轴的排列方式</span><br><span class="line">@mixin flex-align($aitem) &#123;</span><br><span class="line">    -webkit-box-align: $aitem;</span><br><span class="line">    -webkit-align-items: $aitem;</span><br><span class="line">    -ms-flex-align: $aitem;</span><br><span class="line">    align-items: $aitem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只有一个参数，直接传递参数</span><br><span class="line">.container &#123;</span><br><span class="line">    @include flex-align(center);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给指定参数指定值</span><br><span class="line">.footer &#123;</span><br><span class="line">    @include flex-align($aitem: center);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4、使用变量（多参数）"><a href="#2-4、使用变量（多参数）" class="headerlink" title="2.4、使用变量（多参数）"></a>2.4、使用变量（多参数）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义块元素内边距</span><br><span class="line">@mixin block-padding($top, $right, $bottom, $left) &#123;</span><br><span class="line">    padding-top: $top;</span><br><span class="line">    padding-right: $right;</span><br><span class="line">    padding-bottom: $bottom;</span><br><span class="line">    padding-left: $left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按照参数顺序赋值</span><br><span class="line">.container &#123;</span><br><span class="line">    @include block-padding(10px, 20px, 30px, 40px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可指定参数赋值</span><br><span class="line">.container &#123;</span><br><span class="line">    @include block-padding($left: 20px, $top: 10px, $bottom: 10px, $right: 30px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5、指定默认值"><a href="#2-5、指定默认值" class="headerlink" title="2.5、指定默认值"></a>2.5、指定默认值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义块元素内边距，参数指定默认值</span><br><span class="line">@mixin block-padding($top:0, $right:0, $bottom:0, $left:0) &#123;</span><br><span class="line">    padding-top: $top;</span><br><span class="line">    padding-right: $right;</span><br><span class="line">    padding-bottom: $bottom;</span><br><span class="line">    padding-left: $left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可指定参数赋值</span><br><span class="line">.container &#123;</span><br><span class="line">    // 不带参数</span><br><span class="line">    @include block-padding;</span><br><span class="line">    //按顺序指定参数值</span><br><span class="line">    @include block-padding(10px,20px);</span><br><span class="line">    //给指定参数指定值</span><br><span class="line">    @include block-padding($left: 10px, $top: 20px)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-6、可变参数"><a href="#2-6、可变参数" class="headerlink" title="2.6、可变参数"></a>2.6、可变参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line">   定义线性渐变</span><br><span class="line">   @param $direction  方向</span><br><span class="line">   @param $gradients  颜色过度的值列表</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">@mixin linear-gradient($direction, $gradients...) &#123;</span><br><span class="line">    background-color: nth($gradients, 1);</span><br><span class="line">    background-image: linear-gradient($direction, $gradients);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.table-data &#123;</span><br><span class="line">    @include linear-gradient(to right, #F00, orange, yellow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、继承"><a href="#3、继承" class="headerlink" title="3、继承"></a>3、继承</h2><ul><li><code>@extend</code> 指令告诉 <code>Sass</code> 一个选择器的样式从另一选择器继承。如果一个样式与另外一个样式几乎相同，只有少量的区别，则使用 <code>@extend</code> 就显得很有用，<code>@extend</code> 很好的体现了代码的复用</li></ul><h3 id="3-1、基本使用"><a href="#3-1、基本使用" class="headerlink" title="3.1、基本使用"></a>3.1、基本使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.button-basic  &#123;</span><br><span class="line">  border: none;</span><br><span class="line">  padding: 15px 30px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button-report  &#123;</span><br><span class="line">  @extend .button-basic;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button-submit  &#123;</span><br><span class="line">  @extend .button-basic;</span><br><span class="line">  background-color: green;</span><br><span class="line">  color: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2、多层继承"><a href="#3-2、多层继承" class="headerlink" title="3.2、多层继承"></a>3.2、多层继承</h3><p>例如定义两个类，<code>important</code>类继承<code>alert</code>类的样式，<code>alert-danger</code>类继承<code>important</code>的样式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.alert &#123;</span><br><span class="line">    padding: 15px;</span><br><span class="line">    margin-bottom: 20px;</span><br><span class="line">    border: 1px solid transparent;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.important &#123;</span><br><span class="line">    @extend .alert;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.alert-danger &#123;</span><br><span class="line">    @extend .important;</span><br><span class="line">    color: #a94442;</span><br><span class="line">    background-color: #f2dede;</span><br><span class="line">    border-color: #ebccd1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、流程控制语句"><a href="#4、流程控制语句" class="headerlink" title="4、流程控制语句"></a>4、流程控制语句</h2><h3 id="4-1、-if"><a href="#4-1、-if" class="headerlink" title="4.1、@if"></a>4.1、<code>@if</code></h3><p>同 JavaScript 中的 if….else、if …else。代码形式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    // if</span><br><span class="line">    @if(/* 条件 */)&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // if、else</span><br><span class="line">    @if(/* 条件 */)&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;@else&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // if、else if、else</span><br><span class="line">    @if(/* 条件 */)&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;@else if()&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;@else&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2、-for"><a href="#4-2、-for" class="headerlink" title="4.2、@for"></a>4.2、<code>@for</code></h3><p><code>@for</code> 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动<br>这个指令包含两种格式：</p><ul><li><code>@for $var from &lt;start&gt; through &lt;end&gt;</code></li><li><code>@for $var from &lt;start&gt; to &lt;end&gt;</code></li></ul><p>区别在于 <code>through</code> 与 <code>to</code> 的含义：</p><ul><li>使用 <code>through</code> 时，条件范围<strong>包含</strong> <code>&lt;start&gt;</code> 与 <code>&lt;end&gt;</code> 的值</li><li>使用 <code>to</code> 时条件范围<strong>只</strong>包含 <code>&lt;start&gt;</code> 的值不包含 <code>&lt;end&gt;</code> 的值</li></ul><p><code>$var</code> 可以是任何变量，比如 <code>$i</code>；<code>&lt;start&gt;</code> 和 <code>&lt;end&gt;</code> <strong>必须是整数值</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@for $i from 1 through 3 &#123;</span><br><span class="line">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item-1 &#123;</span><br><span class="line">  width: 2em; &#125;</span><br><span class="line">.item-2 &#123;</span><br><span class="line">  width: 4em; &#125;</span><br><span class="line">.item-3 &#123;</span><br><span class="line">  width: 6em; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3、-each"><a href="#4-3、-each" class="headerlink" title="4.3、@each"></a>4.3、<code>@each</code></h3><p><code>@each</code> 指令的格式是 <code>$var in &lt;list&gt;</code></p><ul><li><code>$var</code> 可以是任何变量名，比如 <code>$length</code> 或者 <code>$name</code></li><li><code>&lt;list&gt;</code> 是一连串的值，也就是值列表</li></ul><p><code>@each</code> 将变量<code> $var</code> 作用于值列表中的每一个项目，然后输出结果，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@each $animal in (puma, sea-slug, egret, salamander) &#123;</span><br><span class="line">  .#&#123;$animal&#125;-icon &#123;</span><br><span class="line">    background-image: url(&#x27;/images/#&#123;$animal&#125;.png&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.puma-icon &#123;</span><br><span class="line">  background-image: url(&#x27;/images/puma.png&#x27;); &#125;</span><br><span class="line">.sea-slug-icon &#123;</span><br><span class="line">  background-image: url(&#x27;/images/sea-slug.png&#x27;); &#125;</span><br><span class="line">.egret-icon &#123;</span><br><span class="line">  background-image: url(&#x27;/images/egret.png&#x27;); &#125;</span><br><span class="line">.salamander-icon &#123;</span><br><span class="line">  background-image: url(&#x27;/images/salamander.png&#x27;); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-4、-while"><a href="#4-4、-while" class="headerlink" title="4.4、@while"></a>4.4、<code>@while</code></h3><p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code>更复杂的循环，只是很少会用到。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$i: 6;</span><br><span class="line">@while $i &gt; 0 &#123;</span><br><span class="line">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class="line">  $i: $i - 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item-6 &#123;</span><br><span class="line">  width: 12em; &#125;</span><br><span class="line"></span><br><span class="line">.item-4 &#123;</span><br><span class="line">  width: 8em; &#125;</span><br><span class="line"></span><br><span class="line">.item-2 &#123;</span><br><span class="line">  width: 4em; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5、三元条件函数"><a href="#5、三元条件函数" class="headerlink" title="5、三元条件函数"></a>5、三元条件函数</h2><blockquote><p>判断<code>$condition</code>，如果条件成立，则返回<code>$if-true</code>的结果，如果条件不成立，则返回<code>$if-false</code>的结果</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if($condition, $if-true, $if-false);</span><br><span class="line"></span><br><span class="line">$theme:&#x27;light&#x27;;</span><br><span class="line">.container &#123;</span><br><span class="line">    color: if($theme==&#x27;light&#x27;, #000, #FFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、Map函数"><a href="#6、Map函数" class="headerlink" title="6、Map函数"></a>6、Map函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>map-get(map, key)</td><td>返回 Map 中 key 所对应的 value(值)。如没有对应的 key，则返回 null 值</td></tr><tr><td>map-has-key(map, key)</td><td>判断 map 是否有对应的 key，存在返回 true，否则返回 false</td></tr><tr><td>map-keys(map)</td><td>返回 map 中所有的 key 组成的队列</td></tr><tr><td>map-merge(map1, map2)</td><td>合并两个 map 形成一个新的 map 类型，即将 map2 添加到 map1的尾部</td></tr><tr><td>map-remove(map, keys…)</td><td>移除 map 中的 keys，多个 key 使用逗号隔开</td></tr><tr><td>map-values(map)</td><td>返回 map 中所有的 value 并生成一个队列</td></tr></tbody></table><h2 id="7、-use"><a href="#7、-use" class="headerlink" title="7、@use"></a>7、<code>@use</code></h2><ul><li><code>@use</code>也可以看作是对 <code>@import</code> 的增强</li><li>通过<code>@use</code>引入的样式默认把文件名作为模块名使用，你可以通过<code>as</code>的形式重新取一个别名</li><li><code>@use</code>引入多个文件时，每个文件都是<code>单独的模块</code>，<code>相同变量名不会覆盖</code>，通过模块名访问，而<code>@import</code>变量会被覆盖</li><li>可能<code>@use &#39;&lt;url&gt;&#39; as *</code>来取消命名空间，这种方式加载的模块被提升为<code>全局模块</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@use &#x27;&lt;url&gt;&#x27; [as alias|namespace] </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小知识｜npm scripts 如何将参数正确传递运行的脚本</title>
      <link href="/Kylin-blog/2023/12/25/npm-script/"/>
      <url>/Kylin-blog/2023/12/25/npm-script/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>在公司项目的<code>package.json</code>文件中有个<code>scripts</code>命令：<code>npm run component:add</code>，在命令行输入<code>npm run component:add -g aa -n bb -d cc</code>后，显示的命令变成了<code>node ./packages/scripts component:add aa bb ccc</code>，<code>-</code>都不见了，甚至报错了</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul><li>这里需要用到<code>--</code>，将参数传递给实际的命令</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run component:add -- -g aa -n bb -d cc</span><br></pre></td></tr></table></figure><p>在<code>npm scripts</code>中，<code>--</code>的作用是告诉<code>npm</code>，之后的参数应该传递给运行的脚本，而不是<code>npm</code>自身。当运行<code>npm run script-name -- arg1 arg2</code>时，<code>--</code>之后的参数会被传递给<code>script-name</code>对应的脚本。</p><p>这是因为<code>npm</code>在运行脚本时，它会收集所有在<code>npm run</code>命令之后的参数，并将它们传递给实际执行的命令。但是，如果实际执行的命令也以<code>-</code>开头，npm可能会尝试解析这些参数，而不将它们传递给运行的脚本。</p><p>通过使用<code>--</code>，将告诉<code>npm</code>停止解析参数，并将其余的参数传递给脚本。这样，你就可以确保你的脚本正确地接收到所有的参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小记 </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm-workspaces</title>
      <link href="/Kylin-blog/2023/12/25/npm-workspaces/"/>
      <url>/Kylin-blog/2023/12/25/npm-workspaces/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-workspaces"><a href="#npm-workspaces" class="headerlink" title="npm workspaces"></a>npm workspaces</h2><ul><li>指的是从单个顶级根包中管理本地文件系统中的多个包</li><li><code>npm</code>、<code>yarn</code>、<code>pnpm</code>都提供了对<code>workspaces</code>的支持</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>创建项目文件夹</li><li>对其进行初始化：<code>npm init -y</code></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm-workspaces&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="手动添加子包"><a href="#手动添加子包" class="headerlink" title="手动添加子包"></a>手动添加子包</h3><ul><li>创建<code>packages</code>文件夹，用于存放所有子包</li><li>创建子包：<code>client</code>、<code>server</code>，并对其进行初始化<code>npm init -y</code></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;client&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在根项目的<code>package.json</code>中添加<code>workspaces</code>，其实就是包的路径数组，支持Glob通配符，这里的路径指向指的是<code>package.json</code>所在文件夹文件夹名。</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm-workspaces&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workspaces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">// &quot;packages/*&quot; Glob通配符</span></span><br><span class="line">    <span class="string">&quot;packages/client&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;packages/server&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="命令行添加子包"><a href="#命令行添加子包" class="headerlink" title="命令行添加子包"></a>命令行添加子包</h3><ul><li><code>-w</code> 就是 <code>--workspace</code> 的简写，但用法稍有区别，如下：</li><li>没有层级目录会自动创建，生成<code>pckage.json</code>并在根目录<code>package.json</code>中添加<code>workspace</code>路径</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm init -w ./packages/client -y</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">npm init --workspace=./packages/server -y</span><br></pre></td></tr></table></figure><h3 id="为子包添加、移除、更新依赖"><a href="#为子包添加、移除、更新依赖" class="headerlink" title="为子包添加、移除、更新依赖"></a>为子包添加、移除、更新依赖</h3><blockquote><p>注意：如果在项目根目录运行 <code>npm install</code> 会同时将子包及子包的依赖一起安装到根node_modules下</p></blockquote><ul><li>如果想为<code>client</code>包添加<code>dayjs</code>依赖，可以使用一下命令操作，使用<code>-w [packageName]</code>来告诉<code>npm</code>为哪个子包添加依赖</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install dayjs -w client</span><br><span class="line">npm uninstall dayjs -w client</span><br><span class="line">npm update dayjs -w client</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">npm install dayjs --workspace=client</span><br></pre></td></tr></table></figure><h3 id="几个常用命令"><a href="#几个常用命令" class="headerlink" title="几个常用命令"></a>几个常用命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增子包</span></span><br><span class="line">npm init -w ./packages/client -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为子包添加依赖</span></span><br><span class="line">npm install dayjs -w client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行子包的所有dev脚本</span></span><br><span class="line">npm run dev -w client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行所有子包dev脚本，注意 --if-present 的使用时机</span></span><br><span class="line">npm run dev --workspaces</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript笔记-day5</title>
      <link href="/Kylin-blog/2023/12/22/typescript%E7%AC%94%E8%AE%B0-day5/"/>
      <url>/Kylin-blog/2023/12/22/typescript%E7%AC%94%E8%AE%B0-day5/</url>
      
        <content type="html"><![CDATA[<h2 id="类型查询操作符"><a href="#类型查询操作符" class="headerlink" title="类型查询操作符"></a>类型查询操作符</h2><ul><li><code>typeof</code>：用于基本类型</li></ul><h2 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h2><h3 id="is"><a href="#is" class="headerlink" title="is"></a><code>is</code></h3><ul><li><strong>is 关键字 + 预期类型</strong>。如果这个函数成功返回为 true，那么 is 关键字前这个入参的类型，就会<strong>被这个类型守卫调用，方便后续的类型控制流分析</strong>。</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">input: <span class="built_in">unknown</span></span>): input is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> input === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">input: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(input)) &#123;</span><br><span class="line">    <span class="comment">// 正确了</span></span><br><span class="line">    (input).<span class="title function_">replace</span>(<span class="string">&quot;linbudu&quot;</span>, <span class="string">&quot;linbudu599&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;number&#x27;</span>) &#123; &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><ul><li>通过 <code>key in object</code> 的方式来判断 key 是否存在于 object 或其原型链上（返回 true 说明存在）。</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">fooOnly</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">shared</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">barOnly</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">shared</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">input: Foo | Bar</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> input) &#123;</span><br><span class="line">    input.<span class="property">fooOnly</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    input.<span class="property">barOnly</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h3><ul><li>类似于 typeof 与 in 的操作符，用于引用类型，包括判断A是否是B的实例</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBase</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BarBase</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FooBase</span> &#123;</span><br><span class="line">  <span class="title function_">fooOnly</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">BarBase</span> &#123;</span><br><span class="line">  <span class="title function_">barOnly</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">input: Foo | Bar</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (input <span class="keyword">instanceof</span> <span class="title class_">FooBase</span>) &#123;</span><br><span class="line">    input.<span class="title function_">fooOnly</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    input.<span class="title function_">barOnly</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言守卫asserts"><a href="#类型断言守卫asserts" class="headerlink" title="类型断言守卫asserts"></a>类型断言守卫<code>asserts</code></h2><ul><li><strong>断言守卫和类型守卫最大的不同点在于，在判断条件不通过时，断言守卫需要抛出一个错误，类型守卫只需要剔除掉预期的类型。</strong></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params">condition: <span class="built_in">any</span>, msg?: <span class="built_in">string</span></span>): asserts condition &#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口合并"><a href="#接口合并" class="headerlink" title="接口合并"></a>接口合并</h2><ul><li><p>继承<code>extends</code></p></li><li><p>接口合并，这些同名属性的类型仍然需要兼容</p></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Struct1</span> &#123;</span><br><span class="line">  <span class="attr">primitiveProp</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">objectProp</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="attr">unionProp</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口“Struct2”错误扩展接口“Struct1”。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Struct2</span> <span class="keyword">extends</span> <span class="title class_">Struct1</span> &#123;</span><br><span class="line">  <span class="comment">// “primitiveProp”的类型不兼容。不能将类型“number”分配给类型“string”。</span></span><br><span class="line">  <span class="attr">primitiveProp</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 属性“objectProp”的类型不兼容。</span></span><br><span class="line">  <span class="attr">objectProp</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 属性“unionProp”的类型不兼容。</span></span><br><span class="line">  <span class="comment">// 不能将类型“boolean”分配给类型“string | number”。</span></span><br><span class="line">  <span class="attr">unionProp</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript笔记-day4</title>
      <link href="/Kylin-blog/2023/12/21/typescript%E7%AC%94%E8%AE%B0-day4/"/>
      <url>/Kylin-blog/2023/12/21/typescript%E7%AC%94%E8%AE%B0-day4/</url>
      
        <content type="html"><![CDATA[<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><ul><li>type用于定义类型别名</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IDType</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line"><span class="comment">// 对象类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointType</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">  z?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Handler</span> = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">clickHandler</span>: <span class="title class_">Handler</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">moveHandler</span>: <span class="title class_">Handler</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dragHandler</span>: <span class="title class_">Handler</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: IDType</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printPoint</span>(<span class="params">point: PointType</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>工具类型<ul><li>类型别名可以这么声明自己能够接受泛型（我称之为泛型坑位）</li><li>泛型参数的名称（上面的 T ）也不是固定的。通常我们使用大写的 T &#x2F; K &#x2F; U &#x2F; V &#x2F; M &#x2F; O …这种形式。</li><li>对于工具类型来说，它的主要意义是<strong>基于传入的泛型进行各种类型操作</strong>，得到一个新的类型</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Factory</span>&lt;T&gt; = T | <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型别名：</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FactoryWithBool</span> = <span class="title class_">Factory</span>&lt;<span class="built_in">boolean</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="title class_">FactoryWithBool</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="联合类型-与交叉类型"><a href="#联合类型-与交叉类型" class="headerlink" title="联合类型|与交叉类型&amp;"></a>联合类型<code>|</code>与交叉类型<code>&amp;</code></h2><ul><li>联合类型只需要符合成员之一即可（<code>||</code>），而交叉类型需要严格符合每一位成员（<code>&amp;&amp;</code>）。</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NameStruct</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AgeStruct</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ProfileStruct</span> = <span class="title class_">NameStruct</span> &amp; <span class="title class_">AgeStruct</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">profile</span>: <span class="title class_">ProfileStruct</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;linbudu&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的类型会同时符合交叉类型的所有成员，不存在既是 string 又是 number 的类型</span></span><br><span class="line"><span class="comment">// 这也是 never 这一 BottomType 的实际意义之一，描述根本不存在的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrAndNum</span> = <span class="built_in">string</span> &amp; <span class="built_in">number</span>; <span class="comment">// never</span></span><br></pre></td></tr></table></figure><ul><li>对于对象类型的交叉类型，其<strong>内部的同名属性类型同样会按照交叉类型进行合并</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Struct1</span> = &#123;</span><br><span class="line">  <span class="attr">primitiveProp</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">objectProp</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Struct2</span> = &#123;</span><br><span class="line">  <span class="attr">primitiveProp</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">objectProp</span>: &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Composed</span> = <span class="title class_">Struct1</span> &amp; <span class="title class_">Struct2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PrimitivePropType</span> = <span class="title class_">Composed</span>[<span class="string">&#x27;primitiveProp&#x27;</span>]; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ObjectPropType</span> = <span class="title class_">Composed</span>[<span class="string">&#x27;objectProp&#x27;</span>]; <span class="comment">// &#123; name: string; age: number; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>包含三个部分：<strong>索引签名类型</strong>、<strong>索引类型查询</strong>与<strong>索引类型访问</strong></li></ul><h3 id="索引签名类型"><a href="#索引签名类型" class="headerlink" title="索引签名类型"></a>索引签名类型</h3><ul><li>如下格式：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引类型查询"><a href="#索引类型查询" class="headerlink" title="索引类型查询"></a>索引类型查询</h3><ul><li><code>keyof</code>操作符，返回<strong>索引所有key对应类型字面量的联合类型</strong><ul><li><strong>这里并不会将数字类型的键名转换为字符串类型字面量，而是仍然保持为数字类型字面量</strong>。</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title class_">Kylin</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="number">599</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooKeys</span> = keyof <span class="title class_">Foo</span>; <span class="comment">// &quot;Kylin&quot; | 599</span></span><br><span class="line"><span class="comment">// 在 VS Code 中悬浮鼠标只能看到 &#x27;keyof Foo&#x27;</span></span><br><span class="line"><span class="comment">// 看不到其中的实际值，你可以这么做：</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FooKeys</span> = keyof <span class="title class_">Foo</span> &amp; &#123;&#125;; <span class="comment">// &quot;Kylin&quot; | 599</span></span><br></pre></td></tr></table></figure><ul><li>模拟 <strong>“从键名到联合类型”</strong> 的过程。</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FooKeys</span> = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Foo</span>).<span class="title function_">join</span>(<span class="string">&quot; | &quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">SIZES</span> = [<span class="string">&#x27;mini&#x27;</span>, <span class="string">&#x27;small&#x27;</span>, <span class="string">&#x27;medium&#x27;</span>, <span class="string">&#x27;large&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Size</span> = <span class="keyword">typeof</span> <span class="variable constant_">SIZES</span>[<span class="built_in">number</span>];</span><br></pre></td></tr></table></figure><ul><li>这段代码定义了一个常量数组 <code>SIZES</code>，其中包含了四个字符串元素：<code>mini</code>、<code>small</code>、<code>medium</code>、<code>large</code>。同时，使用 <code>as const</code> 关键字将数组中的元素类型设为<strong>不可变</strong>的<strong>常量</strong>类型。</li><li>接下来，定义了一个<strong>类型别名</strong> <code>Size</code>，它的类型是 <code>typeof SIZES[number]</code>。这个类型别名的意思是，<code>Size</code> 的类型是 <code>SIZES</code> 数组中所有元素的联合类型。<code>[number]</code> 表示数组的索引类型，<code>typeof</code> 表示获取 <code>SIZES</code> 的类型，因此 <code>typeof SIZES[number]</code> 表示获取 <code>SIZES</code> 数组中所有元素的类型，并将它们组成一个<strong>联合类型</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/1700103100385-e8ff1d38-787b-491f-8c7f-995f4df18bc7.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/1700103026651-8da6d23c-1fc4-4f54-bcaa-7e8c7a9167fb.png" alt="img"></p><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><ul><li>映射类型只能使用类型别名实现</li><li><code>in</code>是遍历的意思</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231221142535166.png" alt="image-20231221142535166"></p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Stringify</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>[K in keyof T]: string</code>是一个映射类型（Mapped Type）的语法。这个特定的映射类型 <code>Stringify&lt;T&gt;</code> 会将一个类型 <code>T</code> 的所有属性的类型转换成 <code>string</code> 类型</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">prop1</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">prop2</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">prop3</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">prop4</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringifiedFoo</span> = <span class="title class_">Stringify</span>&lt;<span class="title class_">Foo</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StringifiedFoo</span> &#123;</span><br><span class="line">  <span class="attr">prop1</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">prop2</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">prop3</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">prop4</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript笔记-day3</title>
      <link href="/Kylin-blog/2023/12/20/typescript%E7%AC%94%E8%AE%B0-day3/"/>
      <url>/Kylin-blog/2023/12/20/typescript%E7%AC%94%E8%AE%B0-day3/</url>
      
        <content type="html"><![CDATA[<h2 id="Top-Type"><a href="#Top-Type" class="headerlink" title="Top Type"></a>Top Type</h2><ul><li><p><code>any</code></p><ul><li>会跳过类型检查器对值的检查，<strong>任何值都可以赋值给</strong><code>any</code><strong>类型，</strong><code>any</code><strong>类型的值也可以赋值给任何类型</strong></li><li>可以给一个any类型的变量赋值任何的值，比如数字、字符串的值；</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: <span class="built_in">any</span>[] = [<span class="string">&quot;111&quot;</span>, <span class="number">234</span>] <span class="comment">//不推荐</span></span><br></pre></td></tr></table></figure></li><li><p><code>unknown</code>：</p><ul><li>它用于描述类型不确定的变量</li><li><strong>任何类型的值都可以赋值给unknown类型，但unknow类型只能赋值给any和unknown类型</strong></li><li>any类型可以赋值给任意类型</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">unknown</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">uncertain</span>: <span class="built_in">any</span> = notSure; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">uncertain</span>: <span class="built_in">unknown</span> = notSure; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">unknown</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">uncertain</span>: <span class="built_in">number</span> = notSure; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><h2 id="Bottom-Type"><a href="#Bottom-Type" class="headerlink" title="Bottom Type"></a>Bottom Type</h2><ul><li><code>never</code><ul><li>是<strong>整个类型系统层级中最底层的类型</strong>。</li><li>和 null、undefined 一样，它是所有类型的子类型，但只有 never 类型的变量能够赋值给另一个 never 类型变量。</li><li>表示那些永不存在的值的类型</li><li>函数中是一个死循环或者抛出一个异常</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">justThrow</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言：警告编译器不准报错"><a href="#类型断言：警告编译器不准报错" class="headerlink" title="类型断言：警告编译器不准报错"></a>类型断言：警告编译器不准报错</h2><ul><li>通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。<ul><li>在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型</li></ul></li><li>类型断言好比其它语言里的类型转换</li><li>两种方式实现</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 TypeScript 看来，greaterThan2 的类型既可能是数字，也可能是 undefined，所以上面的示例中提示了一个 ts(2322) 错误，此时我们不能把类型 undefined 分配给类型 number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arrayNumber</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">greaterThan2</span>: <span class="built_in">number</span> = arrayNumber.<span class="title function_">find</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">2</span>); <span class="comment">// 提示 ts(2322)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尖括号 语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as 语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure><h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言!"></a>非空断言<code>!</code></h3><ul><li>排除<code> null</code>及<code> undefined</code></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printMessageLength</span>(<span class="params">message?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="comment">// vue3源码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message!.<span class="property">length</span>) <span class="comment">//message! 非空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printMessageLength</span>(<span class="string">&quot;aaaa&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>确定赋值断言<ul><li><code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x!: <span class="built_in">number</span>;</span><br><span class="line"><span class="title function_">initialize</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> * x); <span class="comment">// Ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h3><ul><li>如果在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;Kylin&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 X 类型 到 Y 类型的断言可能是错误的，blabla</span></span><br><span class="line">(str <span class="keyword">as</span> &#123; <span class="attr">handler</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;).<span class="title function_">handler</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它会提醒你先断言到 unknown 类型，再断言到预期类型，就像这样：</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&quot;Kylin&quot;</span>;</span><br><span class="line"></span><br><span class="line">(str <span class="keyword">as</span> <span class="built_in">unknown</span> <span class="keyword">as</span> &#123; <span class="attr">handler</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;).<span class="title function_">handler</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用尖括号断言</span></span><br><span class="line">(&lt;&#123; <span class="attr">handler</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;&gt;(&lt;<span class="built_in">unknown</span>&gt;str)).<span class="title function_">handler</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型层级"><a href="#类型层级" class="headerlink" title="类型层级"></a>类型层级</h2><ul><li>最顶级的类型，<code>any</code> 与<code> unknown</code></li><li>特殊的 <code>Object</code> ，它也包含了所有的类型，但和 Top Type 比还是差了一层</li><li><code>String</code>、<code>Boolean</code>、<code>Number</code> 这些装箱类型</li><li>原始类型与对象类型</li><li>字面量类型，即更精确的原始类型与对象类型嘛，需要注意的是 <code>null </code>和 <code>undefined</code> 并不是字面量类型的子类型</li><li>最底层的 <code>never</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript笔记-day2</title>
      <link href="/Kylin-blog/2023/12/19/typescript%E7%AC%94%E8%AE%B0-day2/"/>
      <url>/Kylin-blog/2023/12/19/typescript%E7%AC%94%E8%AE%B0-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型签名"><a href="#函数类型签名" class="headerlink" title="函数类型签名"></a>函数类型签名</h3><ul><li>描述了<strong>函数入参类型与函数返回值类型</strong></li><li>要么<strong>直接在函数中进行参数和返回值的类型声明</strong>，要么<strong>使用类型别名将函数声明抽离出来</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">function</span> (<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FuncFoo</span> = <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="title class_">FuncFoo</span> = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name.<span class="property">length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">foo: <span class="built_in">number</span>, bar?: <span class="built_in">boolean</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (bar) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(foo);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo * <span class="number">599</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载签名1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">foo: <span class="built_in">number</span>, bar: <span class="literal">true</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// 重载签名2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">foo: <span class="built_in">number</span>, bar?: <span class="literal">false</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 实现签名，包含重载签名的所有可能情况。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">foo: <span class="built_in">number</span>, bar?: <span class="built_in">boolean</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (bar) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(foo);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo * <span class="number">599</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="title function_">func</span>(<span class="number">599</span>); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="title function_">func</span>(<span class="number">599</span>, <span class="literal">true</span>); <span class="comment">// string</span></span><br><span class="line"><span class="keyword">const</span> res3 = <span class="title function_">func</span>(<span class="number">599</span>, <span class="literal">false</span>); <span class="comment">// number</span></span><br></pre></td></tr></table></figure><ul><li>TypeScript 中的重载更像是伪重载：<ul><li><strong>它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上</strong>。</li><li>而在如 C++ 等语言中，重载体现在多个<strong>名称一致但入参不同的函数实现上</strong>，</li></ul></li></ul><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><ul><li>主要结构只有<ul><li><strong>构造函数</strong></li><li><strong>属性</strong></li><li><strong>方法</strong></li><li><strong>访问符（Accessor）</strong></li></ul></li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><code>public</code>：访问性修饰符，此类成员在<strong>类、类的实例、子类</strong>中都能被访问。</li><li><code>private</code>：访问性修饰符，此类成员仅能在<strong>类的内部</strong>被访问。</li><li><code>protected</code>：访问性修饰符，此类成员仅能在<strong>类与子类中</strong>被访问</li><li><code>readonly</code>：操作性修饰</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="static：静态成员"><a href="#static：静态成员" class="headerlink" title="static：静态成员"></a><code>static</code>：静态成员</h4><ul><li>类的内部静态成员无法通过 this 来访问，需要通过 <code>Foo.staticHandler</code> 这种形式进行访问</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticHandler</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">instanceHandler</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="override："><a href="#override：" class="headerlink" title="override："></a><code>override</code>：</h4><ul><li>确保派生类尝试覆盖的方法一定在基类中存在定义，如下会报错，在基类中未声明<code>print</code></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="title function_">printWithLove</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class的类型"><a href="#class的类型" class="headerlink" title="class的类型"></a>class的类型</h3><ul><li>基类：<code>class Base &#123; &#125;</code></li><li>派生类：<code>class Derived extends Base &#123; &#125;</code></li><li>抽象类：<code>abstract class Abstract&#123; &#125;  </code>：<strong>描述了一个类中应当有哪些成员（属性、方法等）</strong></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsFoo</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="attr">absProp</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">get</span> <span class="title function_">absGetter</span>(): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">absMethod</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现一个抽象类<code>implements</code><ul><li>必须完全实现这个抽象类的每一个抽象成员</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">implements</span> <span class="title class_">AbsFoo</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">absGetter</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;linbudu&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">absMethod</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line">foo.<span class="property">absProp</span> = <span class="string">&#x27;foo&#x27;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231219114716447.png" alt="image-20231219114716447"></p><ul><li><code>interface</code> 不仅可以声明函数结构，也可以声明类的结构：<ul><li><code>interface</code> 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class 自身的类型声明。</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="attr">name</span>:<span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s</span>) &#123; <span class="comment">// s 的类型是 any</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面示例中，类<code>B</code>实现了接口<code>A</code>，但是后者并不能代替<code>B</code>的类型声明。因此，<code>B</code>的<code>get()</code>方法的参数<code>s</code>的类型是<code>any</code>，而不是<code>string</code>。<code>B</code>类依然需要声明参数<code>s</code>的类型。</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">s:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231219115242014.png" alt="image-20231219115242014"></p>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sh脚本</title>
      <link href="/Kylin-blog/2023/12/18/sh%E8%84%9A%E6%9C%AC/"/>
      <url>/Kylin-blog/2023/12/18/sh%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不能随意空格</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/0i1uXf.jpg" alt="Alt text"></p><h2 id="1、echo：打印信息"><a href="#1、echo：打印信息" class="headerlink" title="1、echo：打印信息"></a>1、echo：打印信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Kylin&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/Jqzvg0.jpg"></p><h2 id="2、exit：用于终止脚本的执行，并返回一个退出状态码"><a href="#2、exit：用于终止脚本的执行，并返回一个退出状态码" class="headerlink" title="2、exit：用于终止脚本的执行，并返回一个退出状态码"></a>2、exit：用于终止脚本的执行，并返回一个退出状态码</h2><ul><li>正常退出<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;脚本执行完毕&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></li><li>异常退出<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;参数不足&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3、-0、-1、-2等"><a href="#3、-0、-1、-2等" class="headerlink" title="3、$0、$1、$2等"></a>3、$0、$1、$2等</h2><blockquote><p>假设执行 .&#x2F;test.sh a b c 这样一个命令，则可以使用下面的参数来获取一些值：</p></blockquote><ul><li><code>$0</code> 对应 <code>./test.sh</code> 这个值。如果执行的是 <code>./work/test.sh</code>， 则对应 <code>./work/test.sh</code> 这个值，而不是只返回文件名本身的部分。</li><li><code>$1</code> 会获取到 a，即 $1 对应传给脚本的第一个参数。</li><li><code>$2</code> 会获取到 b，即 $2 对应传给脚本的第二个参数。</li><li><code>$3</code> 会获取到 c，即 $3 对应传给脚本的第三个参数。<code>$4</code>、<code>$5</code> 等参数的含义依此类推。</li></ul><h3 id="3-1、在vue中"><a href="#3-1、在vue中" class="headerlink" title="3.1、在vue中"></a>3.1、在vue中</h3><ul><li><code>npm run test</code></li><li><code>&quot;test&quot;: &quot;sh scripts/test.sh&quot;</code><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;By Kylin&quot;</span></span><br><span class="line"></span><br><span class="line">zero=<span class="variable">$0</span></span><br><span class="line">one=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入了：<span class="variable">$zero</span>, <span class="variable">$one</span>&quot;</span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/SFkC8I.jpg"></li></ul><h2 id="4、if语句"><a href="#4、if语句" class="headerlink" title="4、if语句"></a>4、if语句</h2><ul><li>fi关键词用于标记if语句结尾</li><li>可以使用<code>[]</code>、<code>[[]]</code>、<code>(())</code>等条件表达式</li><li>都需要空格隔开，<code>(())</code>除外<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断语句一 ; <span class="keyword">then</span></span><br><span class="line">command1</span><br><span class="line"><span class="keyword">elif</span> 判断语句二; <span class="keyword">then</span></span><br><span class="line">command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">command3</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;By Kylin&quot;</span></span><br><span class="line">one=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输入了：<span class="variable">$one</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$one</span> &gt; 0 ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;zero大于0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;zero不大于0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/EqvyMX.jpg"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">module_name=<span class="variable">$1</span> </span><br><span class="line">module_name=<span class="variable">$module_name</span> vue-cli-service build</span><br><span class="line"> </span><br><span class="line">file_name=【$(<span class="built_in">date</span> +%m%d)】<span class="variable">$module_name</span>-fe.zip</span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$file_name</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">rm</span> -rf <span class="variable">$file_name</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>zip -r $file_name ./dist</code><br>这段代码的作用是根据传入的参数 <code>$1</code>，生成一个模块名称 <code>module_name</code>，然后使用 <code>Vue CLI Service</code> 进行项目构建。接着，根据当前日期和模块名称生成一个文件名 <code>file_name</code>，并检查是否存在同名的文件。如果存在，则删除该文件。最后，将 <code>./dist</code> 目录下的文件压缩为一个名为 <code>$file_name</code> 的 <code>ZIP</code> 文件。<br>具体解释如下：</p><ol><li><code>module_name=$1</code>： 将传入的第一个参数 $1 赋值给变量 <code>module_name</code>。这个参数可能是一个模块名称，用于后续的文件命名和构建过程。</li><li><code>module_name=$module_name vue-cli-service build</code>： 使用 Vue CLI Service 构建项目。<code>$module_name</code> 是之前定义的模块名称，通过这个命令可以进行项目构建。</li><li><code>file_name=【$(date +%m%d)】$module_name-fe.zip</code>： 根据当前日期和模块名称生成一个文件名 <code>file_name</code>。文件名的格式为 【月日】模块名称-fe.zip，其中 <code>$(date +%m%d)</code> 表示获取当前日期的月份和日期。</li><li><code>if [[ -f $file_name ]]; then</code>： 检查是否存在同名的文件。<code>-f</code> 表示判断文件是否存在，<code>$file_name</code> 是之前定义的文件名。</li><li><code>rm -rf $file_name</code>： 如果存在同名的文件，则使用 <code>rm</code> 命令删除该文件。&#96;-rf 表示递归删除文件和目录。</li><li><code>zip -r $file_name ./dist</code>： 将 <code>./dist</code> 目录下的文件压缩为一个名为 <code>$file_name</code> 的 ZIP 文件。<code>-r</code> 表示递归地将目录及其子目录中的文件都压缩进 ZIP 文件中。</li></ol><h2 id="5、解析日期和时间"><a href="#5、解析日期和时间" class="headerlink" title="5、解析日期和时间"></a>5、解析日期和时间</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">year=`<span class="built_in">date</span> +%Y`</span><br><span class="line">month=`<span class="built_in">date</span> +%m`</span><br><span class="line">day=`<span class="built_in">date</span> +%d`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date +%Y)</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;今天是<span class="variable">$year</span>-<span class="variable">$month</span>-<span class="variable">$day</span>&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/dlzyLK.jpg"></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">year=`<span class="built_in">date</span> +%Y`</span><br><span class="line">month=`<span class="built_in">date</span> +%m`</span><br><span class="line">day=`<span class="built_in">date</span> +%d`</span><br><span class="line">hour=`<span class="built_in">date</span> +%H`</span><br><span class="line">minute=`<span class="built_in">date</span> +%M`</span><br><span class="line">second=`<span class="built_in">date</span> +%S`</span><br></pre></td></tr></table></figure><h2 id="6、read：读取"><a href="#6、read：读取" class="headerlink" title="6、read：读取"></a>6、read：读取</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;请输入你的名称&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/EUXhJ9.jpg"></p><h2 id="7、测试文件"><a href="#7、测试文件" class="headerlink" title="7、测试文件"></a>7、测试文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e name    测试一个文件是否存在</span><br><span class="line">-d name    测试name 是否为一个目录</span><br><span class="line">-f name    测试name 是否为普通文件（而不是目录、设备文件或其他特殊类型的文件）</span><br><span class="line">-L name    测试name 是否为符号链接</span><br><span class="line">-r name    测试name 文件是否存在且为可读</span><br><span class="line">-w name    测试name 文件是否存在且为可写</span><br><span class="line">-x name    测试name 文件是否存在且为可执行</span><br><span class="line">-s name    测试name 文件是否存在且其长度不为0</span><br><span class="line">f1 -nt f2  测试文件f1 是否比文件f2 更新</span><br><span class="line">f1 -ot f2  测试文件f1 是否比文件f2 更旧</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/0lvlh9.jpg"></p><h2 id="8、运算符"><a href="#8、运算符" class="headerlink" title="8、运算符"></a>8、运算符</h2><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/rta0HT.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小记 </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript笔记-day1</title>
      <link href="/Kylin-blog/2023/12/14/typescript%E7%AC%94%E8%AE%B0-day1/"/>
      <url>/Kylin-blog/2023/12/14/typescript%E7%AC%94%E8%AE%B0-day1/</url>
      
        <content type="html"><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><strong>TypeScript Importer</strong>：收集你项目内所有的类型定义，在你敲出<code>:</code>时提供这些类型来进行补全。如果你选择了一个，它还会自动帮你把这个类型导入进来</li><li><strong>Move TS</strong>：通过编辑文件的路径，直接修改项目的目录结构</li><li><strong>Error Lens</strong>：把你的 VS Code 底部问题栏的错误下直接显示到代码文件中的对应位置</li></ul><h2 id="TS文件的快速执行"><a href="#TS文件的快速执行" class="headerlink" title="TS文件的快速执行"></a>TS文件的快速执行</h2><ul><li><strong>ts-node</strong></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i ts-node typescript -g</span><br></pre></td></tr></table></figure><ul><li><strong>ts-node-dev</strong><ul><li>支持自动地监听文件变更然后重新执行</li><li>ts-node-dev 基于 <a href="https://link.juejin.cn/?target=https://github.com/fgnass/node-dev">node-dev</a>（你可以理解一个类似 nodemon 的库，提供监听文件重新执行的能力） 与 <a href="https://link.juejin.cn/?target=https://github.com/TypeStrong/ts-node">ts-node</a> 实现，并在重启文件进程时共享同一个 TS 编译进程，避免了每次重启时需要重新实例化编译进程等操作。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i ts-node-dev -g</span><br></pre></td></tr></table></figure><h2 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h2><ul><li>在 TypeScript 中，<code>null</code> 与 <code>undefined</code> 类型都是<strong>有具体意义的类型</strong></li><li>在没有开启 <code>strictNullChecks</code> 检查的情况下，会<strong>被视作其他类型的子类型</strong>，比如 <code>string</code> 类型会被认为包含了 <code>null</code> 与 <code>undefined</code> 类型</li><li><code>void</code> 表示一个空类型，而 <code>null</code> 与 <code>undefined</code> 都是一个具有意义的实际类型</li></ul><h2 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h2><ul><li>具名元组</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">arr</span>: [<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>, <span class="attr">male</span>: <span class="built_in">boolean</span>] = [<span class="string">&#x27;Kylin&#x27;</span>, <span class="number">18</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><h2 id="type-与-interface"><a href="#type-与-interface" class="headerlink" title="type 与 interface"></a>type 与 interface</h2><ul><li><p><code>type</code>（Type Alias，类型别名）：将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型。</p></li><li><p><code>interface</code> 用来描述<strong>对象、类的结构</strong></p></li><li><p>但大部分场景下接口结构都可以被类型别名所取代，因此，只要你觉得统一使用类型别名让你觉得更整齐，也没什么问题。</p></li></ul><h2 id="object、Object-以及"><a href="#object、Object-以及" class="headerlink" title="object、Object 以及 { }"></a>object、Object 以及 { }</h2><ul><li><code>object</code> 的引入就是为了解决对 <code>Object</code> 类型的错误使用，它代表<strong>所有非原始类型的类型，即数组、对象与函数类型</strong></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tmp17</span>: <span class="built_in">object</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp18</span>: <span class="built_in">object</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp19</span>: <span class="built_in">object</span> = <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp20</span>: <span class="built_in">object</span> = <span class="string">&#x27;Kylin&#x27;</span>;  <span class="comment">// X 不成立，值为原始类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp21</span>: <span class="built_in">object</span> = <span class="number">599</span>; <span class="comment">// X 不成立，值为原始类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp22</span>: <span class="built_in">object</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;Kylin&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp23</span>: <span class="built_in">object</span> = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp24</span>: <span class="built_in">object</span> = [];</span><br></pre></td></tr></table></figure><ul><li><p><code>Object</code>是装箱类型，原型链的顶端是 <code>Object</code> 以及 <code>Function</code>，这也就意味着所有的原始类型与对象类型最终都指向 <code>Object</code>，在 <code>TypeScript</code> 中就表现为 <code>Object</code> 包含了所有的类型。但不应该使用它</p><ul><li><code>Object</code> 类似的<strong>装箱类型</strong>还有 <code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code></li></ul></li><li><p><code>&#123;&#125;</code>代表<strong>对象字面量</strong>类型，或者叫<strong>内部无属性定义的空对象</strong>，可以表示任何非 <code>null / undefined</code> 的值，不应该使用它。</p><ul><li>虽然能够将其作为变量的类型，但你实际上<strong>无法对这个变量进行任何赋值操作</strong>：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tmp30</span>: &#123;&#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;Kylin&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">tmp30.<span class="property">age</span> = <span class="number">18</span>; <span class="comment">// X 类型“&#123;&#125;”上不存在属性“age”。</span></span><br></pre></td></tr></table></figure></li></ul><p>为了更好地区分 <code>Object</code>、<code>object</code> 以及<code>&#123;&#125;</code>这三个具有迷惑性的类型，我们再做下总结：</p><ul><li>在任何时候都<strong>不要，不要，不要使用</strong> <code>Object</code> 以及类似的装箱类型。</li><li>当你不确定某个变量的具体类型，但能确定它不是原始类型，可以使用 <code>object</code>。但我更推荐进一步区分，也就是使用 <code>Record&lt;string, unknown&gt;</code> 或 <code>Record&lt;string, any&gt;</code> 表示对象，<code>unknown[]</code> 或 <code>any[]</code> 表示数组，<code>(...args: any[]) =&gt; any</code>表示函数这样。</li><li>我们同样要避免使用<code>&#123;&#125;</code>。<code>&#123;&#125;</code>意味着任何非 <code>null / undefined</code> 的值，从这个层面上看，使用它和使用 <code>any</code> 一样恶劣。</li></ul><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><ul><li>它代表着<strong>比原始类型更精确</strong>的类型，同时也是原始类型的子类型<ul><li>原始类型的值可以包括任意的同类型值，而字面量类型要求的是<strong>值级别的字面量一致</strong>。</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str</span>: <span class="string">&quot;Kylin&quot;</span> = <span class="string">&quot;Kylin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">num</span>: <span class="number">599</span> = <span class="number">599</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bool</span>: <span class="literal">true</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错！不能将类型“&quot;Kylin599&quot;”分配给类型“&quot;Kylin&quot;”。</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str1</span>: <span class="string">&quot;Kylin&quot;</span> = <span class="string">&quot;Kylin599&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str2</span>: <span class="built_in">string</span> = <span class="string">&quot;Kylin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">str3</span>: <span class="built_in">string</span> = <span class="string">&quot;Kylin599&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>字面量类型主要包括**字符串字面量类型<code>string</code><strong>、</strong>数字字面量类型<code>number</code><strong>、</strong>布尔字面量类型<code>boolean</code><strong>和</strong>对象字面量类型<code>object</code>**，它们可以直接作为类型标注</p></li><li><p>通常与联合类型一起使用：<code>|</code></p><ul><li>对于联合类型中的函数类型，需要使用括号<code>()</code>包裹起来</li><li>函数类型并不存在字面量类型，因此这里的 <code>(() =&gt; &#123;&#125;)</code> 就是一个合法的函数类型</li></ul></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Tmp</span> &#123;</span><br><span class="line">  <span class="attr">bool</span>: <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line">  <span class="attr">str</span>: <span class="string">&quot;aaa&quot;</span> | <span class="string">&quot;bbb&quot;</span> | <span class="string">&quot;ccc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Tmp</span> &#123;</span><br><span class="line">  <span class="attr">mixed</span>: <span class="literal">true</span> | <span class="built_in">string</span> | <span class="number">599</span> | &#123;&#125; | (<span class="function">() =&gt;</span> &#123;&#125;) | (<span class="number">1</span> | <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性，即这一属性如果有字段1，那就没有字段2：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Tmp</span> &#123;</span><br><span class="line">  <span class="attr">user</span>:</span><br><span class="line">    | &#123;</span><br><span class="line">        <span class="attr">vip</span>: <span class="literal">true</span>;</span><br><span class="line">        <span class="attr">expires</span>: <span class="built_in">string</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    | &#123;</span><br><span class="line">        <span class="attr">vip</span>: <span class="literal">false</span>;</span><br><span class="line">        <span class="attr">promotion</span>: <span class="built_in">string</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">tmp</span>: <span class="title class_">Tmp</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp.<span class="property">user</span>.<span class="property">vip</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp.<span class="property">user</span>.<span class="property">expires</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li>数字枚举、字符串枚举；普通枚举、常量枚举</li><li>枚举和对象的重要差异在于，对象是单向映射的，我们只能从键映射到键值。而枚举是双向映射的，即你可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员：</li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Items</span> &#123;</span><br><span class="line">  <span class="title class_">Foo</span>,</span><br><span class="line">  <span class="title class_">Bar</span>,</span><br><span class="line">  <span class="title class_">Baz</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooValue = <span class="title class_">Items</span>.<span class="property">Foo</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> fooKey = <span class="title class_">Items</span>[<span class="number">0</span>]; <span class="comment">// &quot;Foo&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>仅有值为数字的枚举成员才能够进行这样的双向枚举，字符串枚举成员仍然只会进行单次映射</p></li><li><p>默认情况下是数字枚举，且值为依次递增</p></li></ul><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Items</span> &#123;</span><br><span class="line">  <span class="title class_">Foo</span>, <span class="comment">// 0</span></span><br><span class="line">  <span class="title class_">Bar</span>, <span class="comment">// 1</span></span><br><span class="line">  <span class="title class_">Baz</span> <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github图床</title>
      <link href="/Kylin-blog/2023/11/28/github%E5%9B%BE%E5%BA%8A/"/>
      <url>/Kylin-blog/2023/11/28/github%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建github图床"><a href="#搭建github图床" class="headerlink" title="搭建github图床"></a>搭建github图床</h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li>首先需要创建一个公开的仓库，随便什么名字都可以</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128070757568.png" alt="image-20231128070757568"></p><ul><li>（可选）创建<code>img</code>分支，在该分支下创建<code>image</code>文件夹，当然取什么名字在于你</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128071038768.png" alt="image-20231128071038768"></p><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128071107297.png" alt="image-20231128071107297"></p><ul><li>使用<code>oss</code>软件上传图片到<code>github</code>的话，我们需要生成一个<code>github</code>的<code>token</code>，找到<code>Setting</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128071415507.png" alt="image-20231128071415507"></p><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128071439195.png" alt="image-20231128071439195"></p><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128071452109.png" alt="image-20231128071452109"></p><ul><li>按如下操作，当然取什么名字随你，也可自定义过期时间，选择权限范围为<code>repo</code>即可，最后点击<code>generate token</code>即可生成<code>token</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128071544485.png" alt="image-20231128071544485"></p><h2 id="oss软件"><a href="#oss软件" class="headerlink" title="oss软件"></a>oss软件</h2><h3 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h3><ul><li><p>PicGo是一个用于上传图片的客户端，支持拖拽上传、剪贴板上传，功能十分方便。</p></li><li><p>我这用的是<a href="https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/v2.3.1/">山东大学的镜像地址</a>会快一点</p></li><li><p>按照如下设置即可，也可以自定义域名</p></li><li><p>自定义域名需要配置为：<a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E6%89%8D%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87cdn%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%89%87">https://cdn.jsdelivr.net/gh/用户名/仓库名，这样就才可以通过cdn访问图片</a></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128072030573.png" alt="image-20231128072030573"></p><h3 id="uPic"><a href="#uPic" class="headerlink" title="uPic"></a>uPic</h3><ul><li>uPic是一个用于上传图片的客户端，支持拖拽上传、剪贴板上传，功能十分方便。</li><li><a href="https://github.com/gee1k/uPic">github地址</a></li><li><a href="https://github.com/gee1k/uPic/releases">软件下载地址</a></li><li>使用方法也都差不多</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128073547046.png" alt="image-20231128073547046"></p><h2 id="Typora实现自动上传"><a href="#Typora实现自动上传" class="headerlink" title="Typora实现自动上传"></a>Typora实现自动上传</h2><ul><li>在设置中找到图像，按后侧所示设置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxKylin/blog-pic@img/uPic/image-20231128073742110.png" alt="image-20231128073742110"></p><p><img src="https://raw.githubusercontent.com/lxKylin/blog-pic/img/image/202311280800832.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github部署小记</title>
      <link href="/Kylin-blog/2023/11/26/github%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/"/>
      <url>/Kylin-blog/2023/11/26/github%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="github部署hexo博客"><a href="#github部署hexo博客" class="headerlink" title="github部署hexo博客"></a>github部署hexo博客</h1><ul><li>使用了一个公有仓库和私有仓库联合部署，优点是别人看不到源代码</li><li>新建仓库就不多赘述了</li><li>需要在私有仓库设置密钥</li><li>将源代码提交至私密仓库，在<code>.github</code>文件夹下新建<code>workflows</code>文件夹，在这个文件夹下新建<code>xxx.yml</code>文件</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploying</span> <span class="string">Hexo</span> <span class="string">project</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># main 分支有 push 行为时就触发这个 action</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@master</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">theme-keep/hexo-deploy-github-pages-action@master</span> <span class="comment"># 使用专门部署 Hexo 到 GitHub pages 的 action</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">PERSONAL_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_BLOG_TOKEN</span> <span class="string">&#125;&#125;</span> <span class="comment"># secret 名</span></span><br><span class="line">          <span class="attr">PUBLISH_REPOSITORY:</span> <span class="string">xxx/xxx</span> <span class="comment"># 公共仓库，格式：GitHub 用户名/仓库名</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">gh-pages</span> <span class="comment"># 分支，填 gh-pages 就行</span></span><br><span class="line">          <span class="attr">PUBLISH_DIR:</span> <span class="string">./public</span> <span class="comment"># 部署 public 目录下的文件</span></span><br></pre></td></tr></table></figure><ul><li>在私密仓库执行完毕后，会将打包好的<code>public</code>文件中的内容部署到公开仓库中，在公开仓库中需要在<code>Settings</code>中找到<code>Pages</code>，<code>Build and deployment</code></li></ul><p><img src="https://raw.githubusercontent.com/lxKylin/blog-pic/img/image/20231128064001.png"></p><ul><li>这样就会在<code>action</code>执行部署</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/Kylin-blog/2023/11/26/hello-world/"/>
      <url>/Kylin-blog/2023/11/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
